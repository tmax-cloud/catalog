apiVersion: v1
kind: ServiceAccount
metadata:
  name: s2i-helm
secrets:
  - name: <레지스트리 Secret>
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: s2i-helm
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
      - serviceaccounts
      - services
    verbs:
      - get
      - list
      - watch
      - create
      - patch
      - update
  - apiGroups:
      - apps
    resources:
      - deployments
      - replicasets
    verbs:
      - get
      - list
      - watch
      - create
      - patch
      - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: s2i-helm
subjects:
  - kind: ServiceAccount
    name: s2i-helm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: s2i-helm
---
apiVersion: tekton.dev/v1beta1
kind: ClusterTask
metadata:
  name: git-clone
  labels:
    app.kubernetes.io/version: "0.3"
  annotations:
    tekton.dev/pipelines.minVersion: "0.21.0"
    tekton.dev/tags: git
    tekton.dev/displayName: "git clone"
spec:
  description: >-
    These Tasks are Git tasks to work with repositories used by other tasks
    in your Pipeline.

    The git-clone Task will clone a repo from the provided url into the
    output Workspace. By default the repo will be cloned into the root of
    your Workspace. You can clone into a subdirectory by setting this Task's
    subdirectory param. This Task also supports sparse checkouts. To perform
    a sparse checkout, pass a list of comma separated directory patterns to
    this Task's sparseCheckoutDirectories param.

  workspaces:
    - name: output
      description: The git repo will be cloned onto the volume backing this workspace
  params:
    - name: url
      description: git url to clone
      type: string
    - name: revision
      description: git revision to checkout (branch, tag, sha, ref…)
      type: string
      default: ""
    - name: refspec
      description: (optional) git refspec to fetch before checking out revision
      default: ""
    - name: submodules
      description: defines if the resource should initialize and fetch the submodules
      type: string
      default: "true"
    - name: depth
      description: performs a shallow clone where only the most recent commit(s) will be fetched
      type: string
      default: "1"
    - name: sslVerify
      description: defines if http.sslVerify should be set to true or false in the global git config
      type: string
      default: "true"
    - name: subdirectory
      description: subdirectory inside the "output" workspace to clone the git repo into
      type: string
      default: ""
    - name: sparseCheckoutDirectories
      description: defines which directories patterns to match or exclude when performing a sparse checkout
      type: string
      default: ""
    - name: deleteExisting
      description: clean out the contents of the repo's destination directory (if it already exists) before trying to clone the repo there
      type: string
      default: "true"
    - name: httpProxy
      description: git HTTP proxy server for non-SSL requests
      type: string
      default: ""
    - name: httpsProxy
      description: git HTTPS proxy server for SSL requests
      type: string
      default: ""
    - name: noProxy
      description: git no proxy - opt out of proxying HTTP/HTTPS requests
      type: string
      default: ""
    - name: verbose
      description: log the commands used during execution
      type: string
      default: "true"
    - name: gitInitImage
      description: the image used where the git-init binary is
      type: string
      default: "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0"
  results:
    - name: commit
      description: The precise commit SHA that was fetched by this Task
    - name: url
      description: The precise URL that was fetched by this Task
  steps:
    - name: clone
      image: $(params.gitInitImage)
      env:
        - name: PARAM_URL
          value: $(params.url)
        - name: PARAM_REVISION
          value: $(params.revision)
        - name: PARAM_REFSPEC
          value: $(params.refspec)
        - name: PARAM_SUBMODULES
          value: $(params.submodules)
        - name: PARAM_DEPTH
          value: $(params.depth)
        - name: PARAM_SSL_VERIFY
          value: $(params.sslVerify)
        - name: PARAM_SUBDIRECTORY
          value: $(params.subdirectory)
        - name: PARAM_DELETE_EXISTING
          value: $(params.deleteExisting)
        - name: PARAM_HTTP_PROXY
          value: $(params.httpProxy)
        - name: PARAM_HTTPS_PROXY
          value: $(params.httpsProxy)
        - name: PARAM_NO_PROXY
          value: $(params.noProxy)
        - name: PARAM_VERBOSE
          value: $(params.verbose)
        - name: PARAM_SPARSE_CHECKOUT_DIRECTORIES
          value: $(params.sparseCheckoutDirectories)
        - name: WORKSPACE_OUTPUT_PATH
          value: $(workspaces.output.path)
      script: |
        #!/bin/sh
        set -eu -o pipefail

        if [[ "${PARAM_VERBOSE}" == "true" ]] ; then
          set -x
        fi

        CHECKOUT_DIR="${WORKSPACE_OUTPUT_PATH}/${PARAM_SUBDIRECTORY}"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf $CHECKOUT_DIR" because $CHECKOUT_DIR might be "/"
          # or the root of a mounted volume.
          if [[ -d "$CHECKOUT_DIR" ]] ; then
            # Delete non-hidden files and directories
            rm -rf "$CHECKOUT_DIR"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "$CHECKOUT_DIR"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "$CHECKOUT_DIR"/..?*
          fi
        }

        if [[ "${PARAM_DELETE_EXISTING}" == "true" ]] ; then
          cleandir
        fi

        test -z "${PARAM_HTTP_PROXY}" || export HTTP_PROXY="${PARAM_HTTP_PROXY}"
        test -z "${PARAM_HTTPS_PROXY}" || export HTTPS_PROXY="${PARAM_HTTPS_PROXY}"
        test -z "${PARAM_NO_PROXY}" || export NO_PROXY="${PARAM_NO_PROXY}"

        /ko-app/git-init \
          -url "${PARAM_URL}" \
          -revision "${PARAM_REVISION}" \
          -refspec "${PARAM_REFSPEC}" \
          -path "$CHECKOUT_DIR" \
          -sslVerify="${PARAM_SSL_VERIFY}" \
          -submodules="${PARAM_SUBMODULES}" \
          -depth "${PARAM_DEPTH}" \
          -sparseCheckoutDirectories "${PARAM_SPARSE_CHECKOUT_DIRECTORIES}"
        cd "$CHECKOUT_DIR"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "$EXIT_CODE" != 0 ] ; then
          exit $EXIT_CODE
        fi
        # ensure we don't add a trailing newline to the result
        echo -n "$RESULT_SHA" > $(results.commit.path)
        echo -n "${PARAM_URL}" > $(results.url.path)
---
apiVersion: tekton.dev/v1beta1
kind: ClusterTask
metadata:
  name: buildah
  labels:
    app.kubernetes.io/version: "0.2"
  annotations:
    tekton.dev/pipelines.minVersion: "0.17.0"
    tekton.dev/tags: image-build
spec:
  description: >-
    Buildah task builds source into a container image and
    then pushes it to a container registry.

    Buildah Task builds source into a container image using Project Atomic's
    Buildah build tool.It uses Buildah's support for building from Dockerfiles,
    using its buildah bud command.This command executes the directives in the
    Dockerfile to assemble a container image, then pushes that image to a
    container registry.

  params:
    - name: IMAGE
      description: Reference of the image buildah will produce.
    - name: BUILDER_IMAGE
      description: The location of the buildah builder image.
      default: quay.io/buildah/stable:v1.17.0
    - name: STORAGE_DRIVER
      description: Set buildah storage driver
      default: overlay
    - name: DOCKERFILE
      description: Path to the Dockerfile to build.
      default: ./Dockerfile
    - name: CONTEXT
      description: Path to the directory to use as context.
      default: .
    - name: TLSVERIFY
      description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS registry)
      default: "true"
    - name: FORMAT
      description: The format of the built container, oci or docker
      default: "oci"
    - name: BUILD_EXTRA_ARGS
      description: Extra parameters passed for the build command when building images.
      default: ""
    - name: PUSH_EXTRA_ARGS
      description: Extra parameters passed for the push command when pushing images.
      type: string
      default: ""
  workspaces:
    - name: source
    - name: sslcertdir
      optional: true
  results:
    - name: IMAGE_DIGEST
      description: Digest of the image just built.
  steps:
    - name: build
      image: $(params.BUILDER_IMAGE)
      workingDir: $(workspaces.source.path)
      script: |
        [[ "$(workspaces.sslcertdir.bound)" == "true" ]] && CERT_DIR_FLAG="--cert-dir $(workspaces.sslcertdir.path)"
        buildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) bud \
          $(params.BUILD_EXTRA_ARGS) --format=$(params.FORMAT) \
          --tls-verify=$(params.TLSVERIFY) --no-cache \
          -f $(params.DOCKERFILE) -t $(params.IMAGE) $(params.CONTEXT)
      volumeMounts:
        - name: varlibcontainers
          mountPath: /var/lib/containers
      securityContext:
        privileged: true

    - name: push
      image: $(params.BUILDER_IMAGE)
      workingDir: $(workspaces.source.path)
      script: |
        [[ "$(workspaces.sslcertdir.bound)" == "true" ]] && CERT_DIR_FLAG="--cert-dir $(workspaces.sslcertdir.path)"
        buildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) push \
          $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \
          --digestfile $(workspaces.source.path)/image-digest $(params.IMAGE) \
          docker://$(params.IMAGE)
      volumeMounts:
        - name: varlibcontainers
          mountPath: /var/lib/containers
      securityContext:
        privileged: true

    - name: digest-to-results
      image: $(params.BUILDER_IMAGE)
      script: cat $(workspaces.source.path)/image-digest | tee /tekton/results/IMAGE_DIGEST

  volumes:
    - name: varlibcontainers
      emptyDir: {}
---
apiVersion: tekton.dev/v1beta1
kind: ClusterTask
metadata:
  name: helm-upgrade-from-source
  labels:
    app.kubernetes.io/version: "0.2"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: helm
spec:
  description: >-
    These tasks will install / upgrade a helm chart into your Kubernetes /
    OpenShift Cluster using Helm
  params:
    - name: charts_dir
      description: The directory in source that contains the helm chart
    - name: release_version
      description: The helm release version in semantic versioning format
      default: "v1.0.0"
    - name: release_name
      description: The helm release name
      default: "helm-release"
    - name: release_namespace
      description: The helm release namespace
      default: ""
    - name: overwrite_values
      description: "Specify the values you want to overwrite, comma separated: autoscaling.enabled=true,replicas=1"
      default: ""
    - name: values_file
      description: "The values file to be used"
      default: "values.yaml"
    - name: helm_image
      description: "helm image to be used"
      default: "docker.io/lachlanevenson/k8s-helm:v3.3.4@sha256:e1816be207efbd342cba9d3d32202e237e3de20af350617f8507dc033ea66803" #tag: v3.3.4
  workspaces:
    - name: source
    - name: kubeconfig
  steps:
    - name: upgrade
      image: $(params.helm_image)
      workingDir: /workspace/source
      script: |
        echo current installed helm releases
        helm list --namespace "$(params.release_namespace)"

        echo installing helm chart...
        helm upgrade --install --wait --values "$(params.charts_dir)/$(params.values_file)" --kubeconfig "/workspace/kubeconfig/value" --namespace "$(params.release_namespace)" --version $(params.release_version) $(params.release_name) $(params.charts_dir) --debug --set "$(params.overwrite_values)"
---
apiVersion: tekton.dev/v1beta1
kind: ClusterTask
metadata:
  name: build-binary
spec:
  workspaces:
    - name: source
  steps:
    - name: build-binary
      image: gradle:4.10-jdk8
      workingDir: /workspace/source
      script: |
        gradle build
---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: s2i-deploy-helm
spec:
  workspaces:
    - name: source
    - name: kubeconfig
  params:
    - name: git-url
    - name: git-rev
    - name: img-url
    - name: img-tls-verify
  tasks:
    - name: git-clone
      taskRef:
        kind: ClusterTask
        name: git-clone
      workspaces:
        - name: output
          workspace: source
      params:
        - name: url
          value: $(params.git-url)
        - name: revision
          value: $(params.git-rev)
    - name: build-binary
      taskRef:
        kind: ClusterTask
        name: build-binary
      workspaces:
        - name: source
          workspace: source
      runAfter:
        - git-clone
    - name: build-push-image
      taskRef:
        kind: ClusterTask
        name: buildah
      workspaces:
        - name: source
          workspace: source
      params:
        - name: IMAGE
          value: $(params.img-url)
        - name: STORAGE_DRIVER
          value: vfs
        - name: TLSVERIFY
          value: $(params.img-tls-verify)
        - name: FORMAT
          value: docker
      runAfter:
        - build-binary
    - name: helm-deploy
      taskRef:
        kind: ClusterTask
        name: helm-upgrade-from-source
      workspaces:
        - name: source
          workspace: source
        - name: kubeconfig
          workspace: kubeconfig
      params:
        - name: charts_dir
          value: deploy/chart
        - name: release_name
          value: s2i-helm-sample
        - name: overwrite_values
          value: 'image=$(params.img-url)'
      runAfter:
        - build-push-image
---
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: s2i-deploy-helm-run
spec:
  pipelineRef:
    name: s2i-deploy-helm
  serviceAccountName: s2i-helm
  params:
    - name: git-url
      value: <Git 주소>
    - name: git-rev
      value: master
    - name: img-url
      value: <이미지 주소>
    - name: img-tls-verify
      value: "false"
  workspaces:
    - name: source
      volumeClaimTemplate:
        spec:
          accessModes:
            - ReadWriteMany
          storageClassName: csi-cephfs-sc
          resources:
            requests:
              storage: 100Mi
    - name: kubeconfig
      secret:
        secretName: <ClusterName>-kubeconfig
